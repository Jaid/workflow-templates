name: pushDocker
on:
  workflow_call:
    inputs:
      arch:
        type: string
        required: false
        default: ''
        description: List of image archs to build, comma separated without spaces
      buildContext:
        type: string
        required: false
        default: src
      dockerHubUser:
        type: string
        required: false
        default: ''
        description: If unset, the Docker Hub user will be the same as the GitHub user
      dockerHubRegistry:
        type: string
        required: false
        default: docker.io
      githubRegistry:
        type: string
        required: false
        default: ghcr.io
      baseTags:
        type: string
        required: false
        default: type=ref,event=branch
      addShaTags:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the commit’s SHA hash (good for persistence and debugging, but might produce a lot of clutter)
      addScheduleTags:
        type: boolean
        required: false
        default: false
        description: If true, create Docker image tags named after the current date (good for persistence and debugging, but might produce a lot of clutter) (only on schedule events)
      addVersionTag:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the new current version (only on push tag events)
      versionTagPrefix:
        type: string
        required: false
        default: v
        description: Will be appended to the automatically generated version tag (only if addVersionTag is true and event is push tag)
      additionalTags:
        type: string
        required: false
        default: null
      versionTag:
        type: string
        required: false
        default: null
      flavorLatest:
        type: string
        required: false
        default: auto
      flavorPrefix:
        type: string
        required: false
        default: ''
      flavorSuffix:
        type: string
        required: false
        default: ''
      flavorConnectionString:
        type: string
        required: false
        default: '-'
      readmePath:
        type: string
        required: false
        default: readme.md
      # flavorPrefixLatest:
      #   type: string
      #   required: false
      #   default: auto
      # flavorSuffixLatest:
      #   type: string
      #   required: false
      #   default: auto
      buildArgs:
        type: string
        required: false
        default: ''
    secrets:
      dockerHubToken:
        required: false
        description: 'Create here with “Read, Write”: https://hub.docker.com/settings/security?generateToken=true'
    outputs:
      meta:
        value: ${{ jobs.job.outputs.meta }}
      digest:
        value: ${{ jobs.job.outputs.digest }}
      imageId:
        value: ${{ jobs.job.outputs.imageId }}
      imageName:
        value: ${{ jobs.job.outputs.imageName }}
      imageSlug:
        value: ${{ jobs.job.outputs.imageSlug }}
jobs:
  job:
    name: ${{ github.event_name }}${{ inputs.flavorSuffix && ' ' || '' }}${{ inputs.flavorSuffix }}
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
    outputs:
      meta: ${{ steps.dockerPush.outputs.metadata }}
      digest: ${{ steps.dockerPush.outputs.digest }}
      imageId: ${{ steps.dockerPush.outputs.imageid }}
      imageSlug: ${{ steps.dockerHubRef.outputs.ref }}
      imageName: ${{ steps.dockerHubRef.outputs.shortName }}
    steps:
      - name: setupNode
        uses: actions/setup-node@v3.6.0
        with:
          node-version: current
      - name: installActionsToolkitNode
        shell: bash
        run: |
          npm install @actions/core
      - name: getDockerHubTokenLength
        id: getDockerHubTokenLength
        shell: bash
        env:
          dockerHubToken: ${{ secrets.dockerHubToken }}
        run: |
          length=${#dockerHubToken}
          printf 'length=%s' "$length" > $GITHUB_OUTPUT
      - name: getDockerHubUser
        id: getDockerHubUser
        shell: sh -c "node --input-type module < {0}"
        env:
          fallback: ${{github.repository_owner }}
        run: |
          import core from '@actions/core'
          const dockerHubUser = core.getInput('dockerHubUser') || process.env.fallback
          core.setOutput('user', dockerHubUser)
      - name: dockerHubRef
        id: dockerHubRef
        shell: bash
        env:
          dockerHubUser: ${{ steps.getDockerHubUser.outputs.user }}
          repoName: ${{ github.event.repository.name }}
        run: |
          shortName=${repoName##docker-}
          printf shortName=%s "$shortName" > $GITHUB_OUTPUT
          printf '\nref=%s/%s' "$dockerHubUser" "$shortName" >> $GITHUB_OUTPUT
      - name: getCacheInstruction
        id: getCacheInstruction
        shell: bash
        env:
          dockerHubRef: ${{ steps.dockerHubRef.outputs.ref }}
          dockerHubTokenGiven: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && 1 || 0 }}
        run: |
          cacheToSuffix=',mode=max'
          if [[ $dockerHubTokenGiven -ge 1 ]]; then
            cacheInstruction="type=registry,ref=$dockerHubRef:buildcache"
            printf cache-from=%s "$cacheInstruction" > $GITHUB_OUTPUT
            printf '\ncache-to=%s%s' "$cacheInstruction" "$cacheToSuffix" >> $GITHUB_OUTPUT
          else
            cacheInstruction='type=gha'
            printf cache-from=%s "$cacheInstruction" > $GITHUB_OUTPUT
            printf '\ncache-to=%s%s' "$cacheInstruction" "$cacheToSuffix" >> $GITHUB_OUTPUT
          fi
      - name: getImageRefs
        id: getImageRefs
        shell: bash
        env:
          githubRegistry: ${{ inputs.githubRegistry }}
          githubRepository: ${{ github.repository }}
          dockerHubRef: ${{ steps.dockerHubRef.outputs.ref }}
          dockerHubTokenGiven: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && 1 || 0 }}
        run: |
          imageRefs="$githubRegistry/$githubRepository"
          if [[ $dockerHubTokenGiven -ge 1 ]]; then
            imageRefs+="\n$dockerHubRef"
          fi
          printf imageRefs=%s "$imageRefs" > $GITHUB_OUTPUT
      - name: getArch
        id: getArch
        shell: bash
        env:
          givenArch: ${{ inputs.arch }}
        run: |
          if [[ -n $givenArch ]]; then
            arch=$givenArch
          elif [[ -f arch.lines ]]; then
            readarray -t archs < arch.lines
            function joinBy {
              local IFS="$1"; shift; echo "$*"
            }
            arch=$(joinBy , "${archs[@]}");
          else
            arch=linux/amd64,linux/arm/v7,linux/arm64/v8,linux/ppc64le,linux/riscv64,linux/s390x
          fi
          printf arch=%s "$arch" > $GITHUB_OUTPUT
      - name: getTags
        id: getTags
        shell: sh -c "node --input-type module < {0}"
        run: |
          import core from '@actions/core'
          const tags = []
          // TODO I have no idea why this is necessary, but sometimes boolean inputs are not recognized as such and will be returned as empty strings
          const getBooleanInput = key => {
            const value = core.getInput(key)
            if (!value.length) {
              return false
            }
            return core.getBooleanInput(key)
          }
          if (core.getMultilineInput('baseTags')) {
            tags.push(...core.getInput('baseTags').split('\n'))
          }
          if (core.getMultilineInput('additionalTags')) {
            tags.push(...core.getInput('additionalTags').split('\n'))
          }
          if (core.getInput('versionTag')) {
            tags.push(`type=raw,value=${core.getInput('versionTag')}}`)
          }
          if (getBooleanInput('addVersionTag')) {
            tags.push(`type=pep440,pattern=${core.getInput('versionTagPrefix') ?? ''}{{version}}`)
          }
          if (getBooleanInput('addShaTags')) {
            tags.push('type=sha,format=long')
          }
          if (getBooleanInput('addScheduleTags')) {
            tags.push('type=schedule,pattern=nightly')
            tags.push('type=schedule,pattern={{date \'YYYYMMDD\'}}')
          }
          if (!tags.length) {
            core.error('No tags given')
            process.exit(1)
          }
          core.setOutput('tags', tags.map(tag => tag.trim()).join('\n'))
      - name: Checkout
        uses: actions/checkout@v3.5.0
      - name: Set up qemu
        uses: docker/setup-qemu-action@v2.1.0
      - name: Set up buildx
        uses: docker/setup-buildx-action@v2.5.0
      - name: Login to ${{ inputs.dockerHubRegistry }}
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 }}
        uses: docker/login-action@v2.1.0
        with:
          username: ${{ steps.getDockerHubUser.outputs.user }}
          password: ${{ secrets.dockerHubToken }}
      - name: Login to ${{ inputs.githubRegistry }}
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ inputs.githubRegistry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v4.3.0
        with:
          images: ${{ steps.getImageRefs.outputs.imageRefs }}
          labels: |
            maintainer=${{ github.actor }}
            org.opencontainers.image.vendor=${{ github.actor }}
            org.opencontainers.image.title=${{ steps.dockerHubRef.outputs.shortName }}
          tags: ${{ steps.getTags.outputs.tags }}
          flavor: |
            latest=${{ inputs.flavorLatest }}
            prefix=${{ inputs.flavorPrefix && format('{0}{1}', inputs.flavorPrefix, inputs.flavorConnectionString) || '' }}
            suffix=${{ inputs.flavorSuffix && format('{0}{1}', inputs.flavorConnectionString, inputs.flavorSuffix) || '' }}
          # prefixLatest=${{ inputs.flavorPrefixLatest }}
          # suffixLatest=${{ inputs.flavorSuffixLatest }}
      - name: dockerPush
        id: dockerPush
        uses: docker/build-push-action@v4.0.0
        with:
          context: ${{ inputs.buildContext }}
          platforms: ${{ steps.getArch.outputs.arch }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: ${{ inputs.buildArgs }}
          cache-from: ${{ steps.getCacheInstruction.outputs.cache-from }}
          cache-to: ${{ steps.getCacheInstruction.outputs.cache-to }}
          push: true
      - name: dockerPushReadme
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && inputs.readmePath }}
        uses: peter-evans/dockerhub-description@v3.3.0
        with:
          username: ${{ steps.getDockerHubUser.outputs.user }}
          password: ${{ secrets.dockerHubToken }}
          readme-filepath: ${{ inputs.readmePath }}
          repository: ${{ steps.dockerHubRef.outputs.ref }}