name: pushDocker
on:
  workflow_call:
    inputs:
      arch:
        type: string
        required: false
        default: ''
        description: List of image archs to build, comma separated without spaces
      buildContext:
        type: string
        required: false
        default: src
      dockerHubUser:
        type: string
        required: false
        default: ''
        description: If unset, the Docker Hub user will be the same as the GitHub user
      dockerHubRegistry:
        type: string
        required: false
        default: docker.io
      githubRegistry:
        type: string
        required: false
        default: ghcr.io
      baseTags:
        type: string
        required: false
        default: type=ref,event=branch
      addShaTags:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the commit’s SHA hash (good for persistence and debugging, but might produce a lot of clutter)
      addScheduleTags:
        type: boolean
        required: false
        default: false
        description: If true, create Docker image tags named after the current date (good for persistence and debugging, but might produce a lot of clutter) (only on schedule events)
      addVersionTag:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the new current version (only on push tag events)
      versionTagPrefix:
        type: string
        required: false
        default: v
        description: Will be appended to the automatically generated version tag (only if addVersionTag is true and event is push tag)
      additionalTags:
        type: string
        required: false
        default: null
      versionTag:
        type: string
        required: false
        default: null
      flavorLatest:
        type: string
        required: false
        default: auto
      flavorPrefix:
        type: string
        required: false
        default: ''
      flavorSuffix:
        type: string
        required: false
        default: ''
      flavorConnectionString:
        type: string
        required: false
        default: '-'
      readmePath:
        type: string
        required: false
        default: readme.md
      buildArgs:
        type: string
        required: false
        default: ''
    secrets:
      dockerHubToken:
        required: false
        description: 'Create here with “Read, Write”: https://hub.docker.com/settings/security?generateToken=true'
    outputs:
      meta:
        value: ${{ jobs.job.outputs.meta }}
      digest:
        value: ${{ jobs.job.outputs.digest }}
      imageId:
        value: ${{ jobs.job.outputs.imageId }}
      imageName:
        value: ${{ jobs.job.outputs.imageName }}
      imageSlug:
        value: ${{ jobs.job.outputs.imageSlug }}
jobs:
  getDockerImageName:
    name: getDockerImageName
    uses: jaid/workflows/.github/workflows/getDockerImageName.yml@main
    with:
      dockerHubUser: ${{ inputs.dockerHubUser }}
  job:
    needs: getDockerImageName
    name: ${{ github.event_name }}${{ inputs.flavorSuffix && ' ' || '' }}${{ inputs.flavorSuffix }}
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
    outputs:
      meta: ${{ steps.dockerPush.outputs.metadata }}
      digest: ${{ steps.dockerPush.outputs.digest }}
      imageId: ${{ steps.dockerPush.outputs.imageid }}
      imageSlug: ${{ needs.getDockerImageName.outputs.imageSlug }}
      imageUser: ${{ needs.getDockerImageName.outputs.imageUser }}
      imageName: ${{ needs.getDockerImageName.outputs.imageName }}
    steps:
      - name: checkout
        uses: actions/checkout@v3.5.2
      - name: setupNode
        uses: actions/setup-node@v3.6.0
        with:
          node-version: current
      - name: installNodePackages
        shell: bash
        run: |
          cd ..
          npm install --no-package-lock --no-save @actions/core read-file-string
      - name: getDockerHubTokenLength
        id: getDockerHubTokenLength
        shell: sh -c "node --input-type module < {0}"
        env:
          secrets: ${{ toJSON(secrets) }}
        run: |
          import * as core from '@actions/core'
          const secrets = JSON.parse(process.env.secrets)
          core.setOutput('length', secrets.dockerHubToken?.length ?? 0)
      - name: getCacheInstruction
        id: getCacheInstruction
        shell: bash
        env:
          dockerHubRef: ${{ needs.getDockerImageName.outputs.imageSlug }}
          dockerHubTokenGiven: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && 1 || 0 }}
        run: |
          cacheToSuffix=',mode=max'
          if [[ $dockerHubTokenGiven -ge 1 ]]; then
            cacheInstruction="type=registry,ref=$dockerHubRef:buildcache"
            printf cache-from=%s "$cacheInstruction" > $GITHUB_OUTPUT
            printf '\ncache-to=%s%s' "$cacheInstruction" "$cacheToSuffix" >> $GITHUB_OUTPUT
          else
            cacheInstruction='type=gha'
            printf cache-from=%s "$cacheInstruction" > $GITHUB_OUTPUT
            printf '\ncache-to=%s%s' "$cacheInstruction" "$cacheToSuffix" >> $GITHUB_OUTPUT
          fi
      - name: getImageRefs
        id: getImageRefs
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
          dockerHubRef: ${{ needs.getDockerImageName.outputs.imageSlug }}
          getDockerHubTokenLength: ${{ steps.getDockerHubTokenLength.outputs.length }}
        run: |
          import * as core from '@actions/core'
          const inputs = JSON.parse(process.env.inputs)
          const refs = []
          refs.push(`${inputs.githubRegistry}/${inputs.githubRepository}`)
          if (process.env.getDockerHubTokenLength > 0) {
            refs.push(process.env.dockerHubRef)
          }
          const output = refs.join('\n')
          console.dir(output)
          core.setOutput('imageRefs', output)
      - name: getArch
        id: getArch
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
        run: |
          import * as core from '@actions/core'
          import readFileString from 'read-file-string'
          const inputs = JSON.parse(process.env.inputs)
          const getArch = async () => {
            if (inputs.arch) {
              return inputs.arch.split(',')
            } else {
              const archLines = await readFileString.default('arch.lines')
              if (archLines) {
                return archLines.split('\n').map(line => line.trim()).filter(Boolean)
              } else {
                return ['linux/amd64']
              }
            }
          }
          const archs = await getArch()
          core.setOutput('arch', archs.join('\n'))
      - name: getTags
        id: getTags
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
        run: |
          import * as core from '@actions/core'
          const inputs = JSON.parse(process.env.inputs)
          const tags = []
          const add = input => {
            if (!input) {
              return
            }
            let addition
            if (typeof input === 'string') {
              addition = input.split('\n')
            } else {
              addition = input
            }
            for (const tag of addition) {
              if (tag) {
                console.dir(tag)
                tags.push(tag.trim())
              }
            }
          }
          add(inputs.baseTags)
          add(inputs.additionalTags)
          if (inputs.versionTag) {
            add(`type=raw,value=${inputs.versionTag}`)
          }
          if (inputs.addVersionTag) {
            add(`type=pep440,pattern=${inputs.versionTagPrefix ?? ''}{{version}}`)
          }
          if (inputs.addShaTags) {
            add('type=sha,format=long')
          }
          if (inputs.addScheduleTags) {
            add('type=schedule,pattern=nightly')
            add('type=schedule,pattern={{date \'YYYYMMDD\'}}')
          }
          if (!tags.length) {
            core.error('No tags given')
            process.exit(1)
          }
          core.setOutput('tags', tags.join('\n'))
      - name: setupQemu
        if: ${{ steps.getArch.outputs.arch != 'linux/amd64' }}
        uses: docker/setup-qemu-action@v2.1.0
        with:
          platforms: ${{ steps.getArch.outputs.arch }}
      - name: setupBuildx
        uses: docker/setup-buildx-action@v2.5.0
      - name: login (${{ needs.getDockerImageName.outputs.imageUser }} @ ${{ inputs.dockerHubRegistry }})
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 }}
        uses: docker/login-action@v2.1.0
        with:
          username: ${{ needs.getDockerImageName.outputs.imageUser }}
          password: ${{ secrets.dockerHubToken }}
      - name: login (${{ github.actor }} @ ${{ inputs.githubRegistry }})
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ inputs.githubRegistry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: extractDockerMetadata
        id: meta
        uses: docker/metadata-action@v4.4.0
        with:
          images: ${{ steps.getImageRefs.outputs.imageRefs }}
          labels: |
            maintainer=${{ github.actor }}
            org.opencontainers.image.vendor=${{ github.actor }}
            org.opencontainers.image.title=${{ needs.getDockerImageName.outputs.imageName }}
          tags: ${{ steps.getTags.outputs.tags }}
          flavor: |
            latest=${{ inputs.flavorLatest }}
            prefix=${{ inputs.flavorPrefix && format('{0}{1}', inputs.flavorPrefix, inputs.flavorConnectionString) || '' }}
            suffix=${{ inputs.flavorSuffix && format('{0}{1}', inputs.flavorConnectionString, inputs.flavorSuffix) || '' }}
      - name: dockerPush
        id: dockerPush
        uses: docker/build-push-action@v4.0.0
        with:
          context: ${{ inputs.buildContext }}
          platforms: ${{ steps.getArch.outputs.arch }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: ${{ inputs.buildArgs }}
          cache-from: ${{ steps.getCacheInstruction.outputs.cache-from }}
          cache-to: ${{ steps.getCacheInstruction.outputs.cache-to }}
          push: true
      - name: dockerSyncReadme
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && inputs.readmePath }}
        uses: peter-evans/dockerhub-description@v3.4.1
        with:
          username: ${{ needs.getDockerImageName.outputs.imageUser }}
          password: ${{ secrets.dockerHubToken }}
          readme-filepath: ${{ inputs.readmePath }}
          repository: ${{ needs.getDockerImageName.outputs.imageSlug }}