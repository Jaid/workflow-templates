name: pushDocker
on:
  workflow_call:
    inputs:
      arch:
        type: string
        required: false
        default: ''
        description: List of image archs to build, comma separated without spaces
      buildContext:
        type: string
        required: false
        default: src
      dockerHubUser:
        type: string
        required: false
        default: ''
        description: If unset, the Docker Hub user will be the same as the GitHub user
      dockerHubRegistry:
        type: string
        required: false
        default: docker.io
      githubRegistry:
        type: string
        required: false
        default: ghcr.io
      baseTags:
        type: string
        required: false
        default: type=ref,event=branch
      addShaTags:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the commit’s SHA hash (good for persistence and debugging, but might produce a lot of clutter)
      addScheduleTags:
        type: boolean
        required: false
        default: false
        description: If true, create Docker image tags named after the current date (good for persistence and debugging, but might produce a lot of clutter) (only on schedule events)
      addVersionTag:
        type: boolean
        required: false
        default: false
        description: If true, create a Docker image tag named after the new current version (only on push tag events)
      versionTagPrefix:
        type: string
        required: false
        default: v
        description: Will be appended to the automatically generated version tag (only if addVersionTag is true and event is push tag)
      additionalTags:
        type: string
        required: false
        default: null
      versionTag:
        type: string
        required: false
        default: null
      flavorLatest:
        type: string
        required: false
        default: auto
      flavorPrefix:
        type: string
        required: false
        default: ''
      flavorSuffix:
        type: string
        required: false
        default: ''
      flavorConnectionString:
        type: string
        required: false
        default: '-'
      readmePath:
        type: string
        required: false
        default: readme.md
      # flavorPrefixLatest:
      #   type: string
      #   required: false
      #   default: auto
      # flavorSuffixLatest:
      #   type: string
      #   required: false
      #   default: auto
      buildArgs:
        type: string
        required: false
        default: ''
    secrets:
      dockerHubToken:
        required: false
        description: 'Create here with “Read, Write”: https://hub.docker.com/settings/security?generateToken=true'
    outputs:
      meta:
        value: ${{ jobs.job.outputs.meta }}
      digest:
        value: ${{ jobs.job.outputs.digest }}
      imageId:
        value: ${{ jobs.job.outputs.imageId }}
      imageName:
        value: ${{ jobs.job.outputs.imageName }}
      imageSlug:
        value: ${{ jobs.job.outputs.imageSlug }}
jobs:
  getDockerImageName:
    uses: jaid/workflows/.github/workflows/getDockerImageName.yml@main
  job:
    needs: getDockerImageName
    name: ${{ github.event_name }}${{ inputs.flavorSuffix && ' ' || '' }}${{ inputs.flavorSuffix }}
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
    outputs:
      meta: ${{ steps.dockerPush.outputs.metadata }}
      digest: ${{ steps.dockerPush.outputs.digest }}
      imageId: ${{ steps.dockerPush.outputs.imageid }}
      imageSlug: ${{ needs.getDockerImageName.outputs.imageSlug }}
      imageUser: ${{ needs.getDockerImageName.outputs.imageUser }}
      imageName: ${{ needs.getDockerImageName.outputs.imageName }}
    steps:
      - name: Checkout
        uses: actions/checkout@v3.5.0
      - name: setupNode
        uses: actions/setup-node@v3.6.0
        with:
          node-version: current
      - name: installNodePackages
        shell: bash
        run: |
          cd ..
          npm install --no-package-lock --no-save @actions/core read-file-string
      - name: ls
        shell: bash
        run: |
          ls -lah ..
          ls -lah ../node_modules
          ls -lah .
      - name: getDockerHubTokenLength
        id: getDockerHubTokenLength
        shell: sh -c "node --input-type module < {0}"
        env:
          secrets: ${{ toJSON(secrets) }}
        run: |
          import * as core from '@actions/core'
          const secrets = JSON.parse(process.env.secrets)
          core.setOutput('length', secrets.dockerHubToken?.length ?? 0)
      - name: getCacheInstruction
        id: getCacheInstruction
        shell: bash
        env:
          dockerHubRef: ${{ needs.getDockerImageName.outputs.imageSlug }}
          dockerHubTokenGiven: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && 1 || 0 }}
        run: |
          cacheToSuffix=',mode=max'
          if [[ $dockerHubTokenGiven -ge 1 ]]; then
            cacheInstruction="type=registry,ref=$dockerHubRef:buildcache"
            printf cache-from=%s "$cacheInstruction" > $GITHUB_OUTPUT
            printf '\ncache-to=%s%s' "$cacheInstruction" "$cacheToSuffix" >> $GITHUB_OUTPUT
          else
            cacheInstruction='type=gha'
            printf cache-from=%s "$cacheInstruction" > $GITHUB_OUTPUT
            printf '\ncache-to=%s%s' "$cacheInstruction" "$cacheToSuffix" >> $GITHUB_OUTPUT
          fi
      - name: getImageRefs
        id: getImageRefs
        shell: bash
        env:
          githubRegistry: ${{ inputs.githubRegistry }}
          githubRepository: ${{ github.repository }}
          dockerHubRef: ${{ needs.getDockerImageName.outputs.imageSlug }}
          dockerHubTokenGiven: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && 1 || 0 }}
        run: |
          imageRefs="$githubRegistry/$githubRepository"
          if [[ $dockerHubTokenGiven -ge 1 ]]; then
            imageRefs+="\n$dockerHubRef"
          fi
          printf imageRefs=%s "$imageRefs" > $GITHUB_OUTPUT
      - name: getArch
        id: getArch
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
        run: |
          import * as core from '@actions/core'
          import readFileString from 'read-file-string'
          const inputs = JSON.parse(process.env.inputs)
          const getArch = async () => {
            if (inputs.arch?.length) {
              return inputs.arch
            } else {
                archLines = await readFileString('arch.lines')
              if (archLines) {
                return archLines.split('\n').map(line => line.trim()).filter(Boolean).join(',')
              } else {
                return 'linux/amd64,linux/arm/v7,linux/arm64/v8'
              }
            }
          }
          const arch = await getArch()
          core.setOutput('arch', arch)
      - name: getTags
        id: getTags
        shell: sh -c "node --input-type module < {0}"
        env:
          inputs: ${{ toJSON(inputs) }}
        run: |
          import * as core from '@actions/core'
          const inputs = JSON.parse(process.env.inputs)
          const tags = []
          const add = input => {
            if (!input) {
              return
            }
            let addition
            if (typeof input === 'string') {
              addition = input.split('\n')
            } else {
              addition = input
            }
            for (const tag of addition) {
              if (tag) {
                console.dir(tag)
                tags.push(tag.trim())
              }
            }
          }
          add(inputs.baseTags)
          add(inputs.additionalTags)
          if (inputs.versionTag) {
            add(`type=raw,value=${inputs.versionTag}`)
          }
          if (inputs.addVersionTag) {
            add(`type=pep440,pattern=${inputs.versionTagPrefix ?? ''}{{version}}`)
          }
          if (inputs.addShaTags) {
            add('type=sha,format=long')
          }
          if (inputs.addScheduleTags) {
            add('type=schedule,pattern=nightly')
            add('type=schedule,pattern={{date \'YYYYMMDD\'}}')
          }
          if (!tags.length) {
            core.error('No tags given')
            process.exit(1)
          }
          core.setOutput('tags', tags.join('\n'))
      - name: Set up qemu
        if: ${{ steps.getArch.outputs.arch != 'linux/amd64' }}
        uses: docker/setup-qemu-action@v2.1.0
        with:
          platforms: ${{ steps.getArch.outputs.arch }}
      - name: Set up buildx
        uses: docker/setup-buildx-action@v2.5.0
      - name: Login to ${{ inputs.dockerHubRegistry }}
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 }}
        uses: docker/login-action@v2.1.0
        with:
          username: ${{ needs.getDockerImageName.outputs.imageUser }}
          password: ${{ secrets.dockerHubToken }}
      - name: Login to ${{ inputs.githubRegistry }}
        uses: docker/login-action@v2.1.0
        with:
          registry: ${{ inputs.githubRegistry }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v4.3.0
        with:
          images: ${{ steps.getImageRefs.outputs.imageRefs }}
          labels: |
            maintainer=${{ github.actor }}
            org.opencontainers.image.vendor=${{ github.actor }}
            org.opencontainers.image.title=${{ needs.getDockerImageName.outputs.imageName }}
          tags: ${{ steps.getTags.outputs.tags }}
          flavor: |
            latest=${{ inputs.flavorLatest }}
            prefix=${{ inputs.flavorPrefix && format('{0}{1}', inputs.flavorPrefix, inputs.flavorConnectionString) || '' }}
            suffix=${{ inputs.flavorSuffix && format('{0}{1}', inputs.flavorConnectionString, inputs.flavorSuffix) || '' }}
          # prefixLatest=${{ inputs.flavorPrefixLatest }}
          # suffixLatest=${{ inputs.flavorSuffixLatest }}
      - name: dockerPush
        id: dockerPush
        uses: docker/build-push-action@v4.0.0
        with:
          context: ${{ inputs.buildContext }}
          platforms: ${{ steps.getArch.outputs.arch }}
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: ${{ inputs.buildArgs }}
          cache-from: ${{ steps.getCacheInstruction.outputs.cache-from }}
          cache-to: ${{ steps.getCacheInstruction.outputs.cache-to }}
          push: true
      - name: dockerPushReadme
        if: ${{ steps.getDockerHubTokenLength.outputs.length > 0 && inputs.readmePath }}
        uses: peter-evans/dockerhub-description@v3.3.0
        with:
          username: ${{ needs.getDockerImageName.outputs.imageUser }}
          password: ${{ secrets.dockerHubToken }}
          readme-filepath: ${{ inputs.readmePath }}
          repository: ${{ needs.getDockerImageName.outputs.imageSlug }}